# SpringCloud

## 断路器的作用

​		当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）。

- 完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务
- 半开：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭

- 关闭：当服务一直处于正常状态 能正常调用


## 服务熔断,降级
​		在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩

为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。

所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝"当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。

​		服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池,当线程达到阈值的时候就启动服务降级,如果其他请求继续访问就直接返回fallback的默认值

## Eureka自我保护机制
​		当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。



# Springboot
## 自动配置原理

​		通过@EnableAutoConfiguration 作用，利用EnableAutoConfigurationImportSelector给容器中导入一些组件。

1. 扫描所有jar包类路径下 META‐INF/spring.factories
2. 把扫描到的这些文件的内容包装成properties对象
3. 从Properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中

## 配置文件加载的优先级

- file:./config/

- file:./

- classpath:/config/

- classpath:/

​	所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置的内容，并形成互补配置；可以通过spring.config.location来改变默认配置。

​	项目中同时存在application.properties和application.yml文件时，两个文件都有效，但是application.properties的优先级会比application.yml高。


# JVM

## 解释器和JIT区别如何协调使用

- 解释器，直接执行字节码文件，将字节码解释成机器指令，运行效率低
- 及时编译器，翻译成机器指令缓存起来，将热点类进行缓存，运行效率高，但编译机器指令成耗时

两者互相结合起来，类似步行加公交车的组合。

## 指令集架构模型是什么，与寄存器的区别

​		栈和寄存器架构模型。

- 栈的模型指令参数少但是性能低，可跨平台
- 寄存器模型指令参数的性能高，依赖硬件

## 如何减少新生代区的GC时间

​		1.增加新生代区大小

​		2.减少大对象生成

​		3.减少对象生成
## 字节
## 1.String 怎么实现不可变的，通过类反射修改会有什么问题，jvm对字符串有什么特殊处理

1.不提供任何机会修改对象状态的方法

2.保证类不被扩展

3.所有域都是final

4.所有域都是私有的

5.确保对于任何可变组件的互斥访问

```java
//创建字符串"Hello World"， 并赋给引用 s
String s = "Hello World";
System.out.println("s = " + s); //Hello World
//获取String类中的value字段
Field valueFieldOfString = String.class.getDeclaredField("value");
//改变value属性的访问权限
valueFieldOfString.setAccessible(true);`
//获取s对象上的value属性的值`
byte[] value = (byte[]) valueFieldOfString.get(s);
//改变value所引用的数组中的第5个字符
value[5] = '_';
System.out.println("s = " + s); //Hello_World
System.out.println("Hello World".toString());
System.out.println(s == "Hello World"); // true
System.out.println(s.equals("Hello World")); // true
```
​        如上方代码所示，我们定义了一个 String 变量 s ，并且赋值给它 "Hello World"，然后通过 Java 的反射机制去修改第五个字符的值，在输出结果的时候，理所当然的结果是 "Hello_World"，但是我在这个情况之上多了一手，把被修改后的值与初始值比较看看，会发生什么情况，结果一试就出现了问题，竟然与初始值相等且返回了 true .
​        于是，打算好好深究一下，我们知道 String 的变量是存放在 JVM 的常量池中的，同时指向 "Hello World" 的引用 s1 是 String 对象，存放在堆区，我们通过反射区修改的值并不是常量池中的 "Hello World" ，而是 堆区中的对象 s1 的值，所以我们输出 s1 的时候就是 "Hello_World" ，那么为什么初始值比较修改后的值的时候会出现 true 呢？

​        我们看看 System.out.println("Hello World".toString()); 这行代码，输出结果是 Hello_World，这是因为 "Hello World".toString() 的时候，会去常量池中去找 "Hello World"的引用，它的引用就是 s1 ，所以输出的是 s1 的值，即 "Hello_World"，所以，到这里，我们就知道了，为什么 s == "Hello World" 和 s.equals("Hello World") 返回 true 了 .

## 2.Hashmap的put过程，什么时候扩容，前后扩容的好处。有几次扩容处理，为什么

https://blog.csdn.net/weixin_43999327/article/details/107870984

HashMap的put方法流程如下：

1.判断数组table是否为null或者长度为零，如果是则扩容
2.计算hash值，计算位置i，如果table[i]为null，直接插入，让size+1,判断是否需要扩容，结束。
3.如果不为null，判断table[i]的key是否与要插入元素的key是否相等，如果是，判断是否需要覆盖旧值，结束。
4.如果不相等，判断table[i]对应的元素是否为红黑树节点，如果是，执行红黑树插入方法，判断是否需要覆盖旧值，让size+1,判断是否需要扩容，结束。
5.如果不是，遍历链表，判断链表中有无与要插入元素的key相等的元素，如果有，判断是否需要覆盖旧值，结束。
6.如果没有，让元素插入到链表最后面。
7.如果链表的长度大于等于8，并且桶的个数小于64，则扩容，如果桶的个数大于64则转为红黑树。
8.让size+1判断是否需要扩容。

负载因子如何选择，会自己动态调整吗?

https://blog.csdn.net/woaiwym/article/details/80622804

##  3.jvm垃圾回收过程和垃圾回收器

https://blog.csdn.net/u011534095/article/details/78845080

1.什么情况下会发生栈内存溢出。
思路： 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。

我的答案：

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)
参数 -Xss 去调整JVM栈的大小
2.详解JVM内存模型
思路： 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。

我的答案：

JVM内存结构




程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。

Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。

Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。

Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。

方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享

3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
思路： 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。

我的答案：

1）共享内存区划分

共享内存区 = 持久带 + 堆
持久带 = 方法区 + 其他
Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
2）一些参数的配置

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)
Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)
3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）
4.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代
思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。

我的答案：

Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。
5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
思路： 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。

我的答案：

1）几种垃圾收集器：

Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。
Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。
2）CMS收集器和G1收集器的区别：

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。
思路： 先画出Java内存模型图，结合例子volatile ，说明什么是重排序，内存屏障，最好能给面试官写以下demo说明。

我的答案：

1）Java内存模型图：



 

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

2）指令重排序。

在这里，先看一段代码

public class PossibleReordering {
static int x = 0, y = 0;
static int a = 0, b = 0;

public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new Runnable() {
        public void run() {
            a = 1;
            x = b;
        }
    });

    Thread other = new Thread(new Runnable() {
        public void run() {
            b = 1;
            y = a;
        }
    });
    one.start();other.start();
    one.join();other.join();
    System.out.println(“(” + x + “,” + y + “)”);
}
运行结果可能为(1,0)、(0,1)或(1,1)，也可能是(0,0)。因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是指令重排。

3）内存屏障

内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。

LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
4）happen-before原则

单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。
happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。
线程中断的happen-before原则 ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
线程终结的happen-before原则： 线程中的所有操作都happen-before线程的终止检测。
对象创建的happen-before原则： 一个对象的初始化完成先于他的finalize方法调用。
7.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
思路： 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲委派模型，最后阐述怎么打破双亲委派模型。

我的答案：

1) 什么是类加载器？

类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。
2）双亲委派模型

双亲委派模型工作过程是：

如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

双亲委派模型图：



 

3）为什么需要双亲委派模型？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码

4）怎么打破双亲委派模型？

打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。

8.说说你知道的几种主要的JVM参数
思路： 可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。

我的答案：

1）堆栈配置相关

java -Xmx3550m -Xms3550m -Xmn2g -Xss128k 
-XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0
-Xmx3550m： 最大堆大小为3550m。

-Xms3550m： 设置初始堆大小为3550m。

-Xmn2g： 设置年轻代大小为2g。

-Xss128k： 每个线程的堆栈大小为128k。

-XX:MaxPermSize： 设置持久代大小为16m

-XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。

-XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6

-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

2）垃圾收集器相关

-XX:+UseParallelGC
-XX:ParallelGCThreads=20
-XX:+UseConcMarkSweepGC 
-XX:CMSFullGCsBeforeCompaction=5
-XX:+UseCMSCompactAtFullCollection：
-XX:+UseParallelGC： 选择垃圾收集器为并行收集器。

-XX:ParallelGCThreads=20： 配置并行收集器的线程数

-XX:+UseConcMarkSweepGC： 设置年老代为并发收集。

-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。

-XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片

3）辅助信息相关

-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGC 输出形式:

[GC 118250K->113543K(130112K), 0.0094143 secs] [Full GC 121376K->10414K(130112K), 0.0650971 secs]

-XX:+PrintGCDetails 输出形式:

[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs

9.怎么打出线程栈信息。
思路： 可以说一下jps，top ，jstack这几个命令，再配合一次排查线上问题进行解答。

我的答案：

输入jps，获得进程号。
top -Hp pid 获取本进程中所有线程的CPU耗时性能
jstack pid命令查看当前java进程的堆栈状态
或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。
可以使用fastthread 堆栈定位，fastthread.io/
10.强引用、软引用、弱引用、虚引用的区别？
思路： 先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。

我的答案：

1）强引用

我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

2）软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码：

Browser prev = new Browser();               // 获取页面进行浏览
SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用        
if(sr.get()!=null){ 
    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取
}else{
    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了
    sr = new SoftReference(prev);       // 重新构建
}
3）弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc();
4）虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

## 4.线程池和threadlocal一起配合使用有什么问题

​        在使用线程池的时候再使用 ThreadLocal 变量就会有一个，同一个工作线程执行不同的任务时，ThreadLocal变量就会有脏读的现象。

​        ThreadLocal就是在每个线程 Thread 类里的变量 ThreadLocalMap。而ThreadLocalMap 这个Map和HashMap类似。从这可以看出来，ThreadLocal 中有一个在每个线程中不一样的Map(因为是Thread类的成员变量)，所以实现了一个多个线程隔离的数据集。

## 5.Java四种引用

１．强引用

是指创建一个对象并把这个对象赋给一个引用变量。

比如：

```java
Object object = new Object();
String str ="hello";
```

 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

2.软引用（SoftReference）

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；

如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。
SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。

也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。

另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。

```java
MyObject aRef = new  MyObject();  
SoftReference aSoftRef=new SoftReference(aRef);
```

此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。

随即，我们可以结束aReference对这个MyObject实例的强引用:

```java
aRef = null; 
```

此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。
Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。
也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:

```java
MyObject anotherRef=(MyObject)aSoftRef.get(); 
```

重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。

使用ReferenceQueue清除失去了软引用对象的SoftReference：

作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:

```java
ReferenceQueue queue = new  ReferenceQueue();  
SoftReference ref =new  SoftReference(aMyObject, queue);
```

那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。

在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:

```java
SoftReference ref = null;  
while ((ref = (EmployeeRef) q.poll()) != null) {  
    // 清除ref  
}
```

3.弱引用（WeakReference）

弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：

```java
public class test {  
    public static void main(String[] args) {  
        WeakReference<People>reference=new WeakReference<People>(new People("zhouqian",20));  
        System.out.println(reference.get());  
        System.gc();//通知GVM回收资源  
        System.out.println(reference.get());  
    }  
}  
class People{  
    public String name;  
    public int age;  
    public People(String name,int age) {  
        this.name=name;  
        this.age=age;  
    }  
    @Override  
    public String toString() {  
        return "[name:"+name+",age:"+age+"]";  
    }  
}  
```

输出结果：

[name:zhouqian,age:20]
null
第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。

比如：将代码做一点小更改：

```java
public class test {  
    public static void main(String[] args) {  
        People people=new People("zhouqian",20);  
        WeakReference<People>reference=new WeakReference<People>(people);//关联强引用      
        System.out.println(reference.get());  
        System.gc();  
        System.out.println(reference.get());  
    }  
}  
class People{  
    public String name;  
    public int age;  
    public People(String name,int age) {  
        this.name=name;  
        this.age=age;  
    }  
    @Override  
    public String toString() {  
        return "[name:"+name+",age:"+age+"]";  
    }  
}
```

结果发生了很大的变化:

[name:zhouqian,age:20] 

[name:zhouqian,age:20] 

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。

4.虚引用（PhantomReference）

​        虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

```java
public class Main {  
    public static void main(String[] args) {  
        ReferenceQueue<String> queue = new ReferenceQueue<String>();  
        PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);  
        System.out.println(pr.get());  
    }  
}  
```

## 6.手写单例，类反射破环单例模式

单例模式，保证一个类仅有一个实例，并且提供一个访问它的全局访问点

### (1) 优点

- 提供了对唯一实例的受控访问
- 保证了内存中只有唯一实例，减少了内存的开销
  - 尤其表现在一些需要多次创建销毁实例的情况下
- 避免对资源的多重占用
  - 比如对文件的写操作

### (2) 缺点

- 单例模式中没有抽象层，没有接口，不能继承，扩展困难，扩展需要修改原来的代码，违背了 “开闭原则”
- 单例类的代码一般写在同一个类中，一定程度上职责过重，违背了 “单一职责原则”

## (一)饿汉式

我们就按照最基本的这三点来写

```java
public class Hungry {
    // 构造器私有，静止外部new
    private Hungry(){}
    // 在类的内部创建自己的实例
    private static Hungry hungry = new Hungry();
    // 获取本类实例的唯一全局访问点
    public static Hungry getHungry(){
        return hungry;
    }
}
```

这种做法一开始就直接创建这个实例，我们也称为饿汉式单例，但是如果这个实例一直没有被调用，会造成内存的浪费，显然这样做是不合适的。

## (二) 懒汉式

饿汉式的主要问题在于，一开始就创建实例导致的内存浪费问题，那么我们将创建对象的步骤，挪到具体使用的时候

```java
public class Lazy1 {
    // 构造器私有，静止外部new
    private Lazy1(){
        System.out.println(Thread.currentThread().getName() + " 访问到了");
    }
    // 定义即可，不真正创建
    private static Lazy1 lazy1 = null;
    // 获取本类实例的唯一全局访问点
    public static Lazy1 getLazy1(){
        // 如果实例不存在则new一个新的实例，否则返回现有的实例
        if (lazy1 == null) {
            lazy1 = new Lazy1();
        }
        return lazy1;
    }
    public static void main(String[] args) {
        // 多线程访问，看看会有什么问题
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                Lazy1.getLazy1();
            }).start();
        }
    }
}
```

例如上述代码，我们只在刚开始做了一个定义，真正的实例化是在调用 getLazy1() 时被执行

单线程环境下是没有问题的，但是多线程的情况下就会出现问题，例如下面是我运行结果中的一次：

Thread-0 访问到了

Thread-4 访问到了 

Thread-1 访问到了

 Thread-3 访问到了

 Thread-2 访问到了

## (三) DCL 懒汉式

### (1) 方法上直接加锁

很显然，多线程下的普通懒汉式出现了问题，这个时候，我们只需要加一层锁就可以解决

简单的做法就是在方法前加上 synchronized 关键字

```java
public static synchronized Lazy1 getLazy1(){
    if (lazy1 == null) {
        lazy1 = new Lazy1();
    }
    return lazy1;
}
```

### (2) 缩小锁的范围

但是我们又想缩小锁的范围，毕竟方法上加锁，多线程中效率会低一些，所以只把锁加到需要的代码上

我们直观的可能会这样写

```java
public static Lazy1 getLazy1(){
    if (lazy1 == null) {
    	synchronized(Lazy1.class){
    		lazy1 = new Lazy1();
    	}
   	}
    return lazy1;
}
```

但是这样还是有问题的

### (3) 双重锁定

当线程 A 和 B 同时访问getLazy1()，执行到到 `if (lazy1 == null)` 这句的时候，同时判断出 lazy1 == null，也就同时进入了 if 代码块中，后面因为加了锁，只有一个能先执行实例化的操作，例如 A 先进入，但是 后面的 B 进入后同样也可以创建新的实例，就达不到单例的目的了，不信可以自己试一下

解决的方式就是再进行第二次的判断

```java
// 获取本类实例的唯一全局访问点
public static Lazy1 getLazy1(){
    // 如果实例不存在则new一个新的实例，否则返回现有的实例
    if (lazy1 == null) {
        // 加锁
        synchronized(Lazy1.class){
            // 第二次判断是否为null
            if (lazy1 == null){
                lazy1 = new Lazy1();
            }
        }
    }
    return lazy1;
}
```

### (4) 指令重排问题

这种在适当位置加锁的方式，尽可能的降低了加锁对于性能的影响，也能达到预期效果

但是这段代码，在一定条件下还是会有问题，那就是指令重排问题

> 指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。

什么意思呢？

首先要知道 `lazy1 = new Lazy1();` 这一步并不是一个原子性操作，也就是说这个操作会分成很多步

- ① 分配对象的内存空间
- ② 执行构造函数，初始化对象
- ③ 指向对象到刚分配的内存空间

但是 JVM 为了效率对这个步骤进行了重排序，例如这样：

- ① 分配对象的内存空间
- **③ 指向对象到刚分配的内存空间，对象还没被初始化**
- ② 执行构造函数，初始化对象

按照 ① ③ ② 的顺序，当 A 线程执行到 ② 后，B线程判断 lazy1 != null ，但是此时的 lazy1 还没有被初始化，所以会出问题，并且这个过程中 B 根本执行到锁那里，配个表格说明一下：

| Time | ThreadA                                           | ThreadB                                             |
| ---- | ------------------------------------------------- | --------------------------------------------------- |
| t1   | A：① 分配对象的内存空间                           |                                                     |
| t2   | A：③ 指向对象到刚分配的内存空间，对象还没被初始化 |                                                     |
| t3   |                                                   | B：判断 lazy1 是否为 null                           |
| t4   |                                                   | B：判断到 lazy1 != null，返回了一个没被初始化的对象 |
| t5   | A：② 初始化对象                                   |                                                     |

解决的方法很简单——在定义时增加 volatile 关键字，避免指令重排

### (5) 最终代码

最终代码如下：

```java
public class Lazy1 {
    // 构造器私有，静止外部new
    private Lazy1(){
        System.out.println(Thread.currentThread().getName() + " 访问到了");
    }
    // 定义即可，不真正创建
    private static volatile Lazy1 lazy1 = null;
    // 获取本类实例的唯一全局访问点
    public static Lazy1 getLazy1(){
        // 如果实例不存在则new一个新的实例，否则返回现有的实例
        if (lazy1 == null) {
            // 加锁
            synchronized(Lazy1.class){
                // 第二次判断是否为null
                if (lazy1 == null){
                    lazy1 = new Lazy1();
                }
            }
        }
        return lazy1;
    }
    public static void main(String[] args) {
        // 多线程访问，看看会有什么问题
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                Lazy1.getLazy1();
            }).start();
        }
    }
}
```

## (四) 静态内部类懒汉式

双重锁定算是一种可行不错的方式，而静态内部类就是一种更加好的方法，不仅速度较快，还保证了线程安全，先看代码

```java
public class Lazy2 {
    // 构造器私有，静止外部new
    private Lazy2(){
        System.out.println(Thread.currentThread().getName() + " 访问到了");
    }
    // 用来获取对象
    public static Lazy2 getLazy2(){
        return InnerClass.lazy2;
    }
    // 创建内部类
    public static class InnerClass {
        // 创建单例对象
        private static Lazy2 lazy2 = new Lazy2();
    }
    public static void main(String[] args) {
        // 多线程访问，看看会有什么问题
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                Lazy2.getLazy2();
            }).start();
        }
    }
}
```

上面的代码，首先 InnerClass 是一个内部类，其在初始化时是不会被加载的，当用户执行了 getLazy2() 方法才会加载，同时创建单例对象，所以他也是懒汉式的方法，因为 InnerClass 是一个静态内部类，所以只会被实例化一次，从而达到线程安全，因为并没有加锁，所以性能上也会很快，所以一般是推荐的

## (五) 枚举方式

最后推荐一个非常好的方式，那就是枚举单例方式，其不仅简单，且保证了安全，先看一下 《Effective Java》中作者的说明：

> 这种方法在功能上与公有域方法相似，但更加简洁无偿地提供了序列化机制，绝对防止多次实例化。即使是在面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，**但是单元素的枚举类型经常成为实现Singleton 的最佳方法**，注意，如果 Singleton 必须扩展一个超类，而不是扩展 enum 时则不宜使用这个方法，（虽然可以声明枚举去实现接口）。
>
> 节选自 《Effective Java》第3条：用私有构造器或者枚举类型强化 Singleton 属性
>
> 原著：Item3: Enforce the singleton property with a private constructor or an enum

代码就这样，简直不要太简单，访问通过 `EnumSingle.IDEAL` 就可以访问了

```java
public enum EnumSingle {
    IDEAL;
}
```

我们接下来就要给大家演示为什么枚举是一种比较安全的方式

# 三 反射破坏单例模式

## (一) 单例是如何被破坏的

下面用双重锁定的懒汉式单例演示一下，这是我们原来的写法，new 两个实例出来，输出一下

```java
public class Lazy1 {
    // 构造器私有，静止外部new
    private Lazy1(){
        System.out.println(Thread.currentThread().getName() + " 访问到了");
    }
    // 定义即可，不真正创建
    private static volatile Lazy1 lazy1 = null;
    // 获取本类实例的唯一全局访问点
    public static Lazy1 getLazy1(){
        // 如果实例不存在则new一个新的实例，否则返回现有的实例
        if (lazy1 == null) {
            // 加锁
            synchronized(Lazy1.class){
                // 第二次判断是否为null
                if (lazy1 == null){
                    lazy1 = new Lazy1();
                }
            }
        }
        return lazy1;
    }
    public static void main(String[] args) {
        Lazy1 lazy1 = getLazy1();
        Lazy1 lazy2 = getLazy1();
        System.out.println(lazy1);
        System.out.println(lazy2);

    }
}
```

运行结果：
main 访问到了
cn.ideal.single.Lazy1@1b6d3586
cn.ideal.single.Lazy1@1b6d3586

可以看到，结果是单例没有问题

### (1) 一个普通实例化，一个反射实例化

但是我们如果通过反射的方式进行实例化类，会有什么问题呢？

```java
public static void main(String[] args) throws Exception {
    Lazy1 lazy1 = getLazy1();
    // 获得其空参构造器
    Constructor<Lazy1>  declaredConstructor = Lazy1.class.getDeclaredConstructor(null);
    // 使得可操作性该 declaredConstructor 对象
    declaredConstructor.setAccessible(true);
    // 反射实例化
    Lazy1 lazy2 = declaredConstructor.newInstance();
    System.out.println(lazy1);
    System.out.println(lazy2);
}
```

getDeclaredConstructor() 方法说明

> 方法返回一个Constructor对象，它反映此Class对象所表示的类或接口指定的构造函数。parameterTypesparameter是确定构造函数的形参类型，在Class对象声明顺序的数组。
>
> public Constructor getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException

运行结果：

main 访问到了
main 访问到了
cn.ideal.single.Lazy1@1b6d3586
cn.ideal.single.Lazy1@4554617c

可以看到，单例被破坏了

**解决办法：因为我们反射走的其无参构造，所以在无参构造中再次进行非null判断，加上原来的双重锁定，现在也就有三次判断了**

```java
// 构造器私有，静止外部new
private Lazy1(){
    synchronized (Lazy1.class){
        if(lazy1 != null) {
            throw new RuntimeException("反射破坏单例异常");
        } 
    }
}
```

不过结果也没让人失望，这种测试下，第二次实例化会直接报异常

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7863f754bd4643fc8dcd773489ad7ea7~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7863f754bd4643fc8dcd773489ad7ea7~tplv-k3u1fbpfcp-zoom-1.image)

### (2) 两个都是反射实例化

如果两个都是反射实例化出来的，也就是说，根本就不去调用 getLazy1() 方法，那可怎么办？

如下：

```java
public static void main(String[] args) throws Exception {

    // 获得其空参构造器
    Constructor<Lazy1> declaredConstructor = Lazy1.class.getDeclaredConstructor(null);
    // 使得可操作性该 declaredConstructor 对象
    declaredConstructor.setAccessible(true);
     // 反射实例化
    Lazy1 lazy1 = declaredConstructor.newInstance();
    Lazy1 lazy2 = declaredConstructor.newInstance();

    System.out.println(lazy1);
    System.out.println(lazy2);
}
```

运行结果：

main 访问到了
main 访问到了
cn.ideal.single.Lazy1@1b6d3586
cn.ideal.single.Lazy1@4554617c

单例又被破坏了

**解决方案：增加一个标识位，例如下文通过增加一个布尔类型的 ideal 标识，保证只会执行一次，更安全的做法，可以进行加密处理，保证其安全性**

```java
// 构造器私有，静止外部new
private Lazy1(){
    synchronized (Lazy1.class){
        if (ideal == false){
            ideal = true;
        } else {
            throw new RuntimeException("反射破坏单例异常");
        }
    }
	System.out.println(Thread.currentThread().getName() + " 访问到了");
}
```

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c9163b82d24374af7651d5b1ed7776~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c9163b82d24374af7651d5b1ed7776~tplv-k3u1fbpfcp-zoom-1.image)

这样就没问题了吗，并不是，一旦别人通过一些手段得到了这个标识内容，那么他就可以通过修改这个标识继续破坏单例，代码如下（这个把代码贴全一点，前面都是节选关键的，都可以参考这个）

```java
public class Lazy1 {
    private static boolean ideal = false;
    // 构造器私有，静止外部new
    private Lazy1(){
        synchronized (Lazy1.class){
            if (ideal == false){
                ideal = true;
            } else {
                throw new RuntimeException("反射破坏单例异常");
            }
        }
        System.out.println(Thread.currentThread().getName() + " 访问到了");
    }
    // 定义即可，不真正创建
    private static volatile Lazy1 lazy1 = null;
    // 获取本类实例的唯一全局访问点
    public static Lazy1 getLazy1(){
        // 如果实例不存在则new一个新的实例，否则返回现有的实例
        if (lazy1 == null) {
            // 加锁
            synchronized(Lazy1.class){
                // 第二次判断是否为null
                if (lazy1 == null){
                    lazy1 = new Lazy1();
                }
            }
        }
        return lazy1;
    }
    public static void main(String[] args) throws Exception {
        Field ideal = Lazy1.class.getDeclaredField("ideal");
        ideal.setAccessible(true);
        // 获得其空参构造器
        Constructor<Lazy1> declaredConstructor = Lazy1.class.getDeclaredConstructor(null);
        // 使得可操作性该 declaredConstructor 对象
        declaredConstructor.setAccessible(true);
        // 反射实例化
        Lazy1 lazy1 = declaredConstructor.newInstance();
        ideal.set(lazy1,false);
        Lazy1 lazy2 = declaredConstructor.newInstance();
        System.out.println(lazy1);
        System.out.println(lazy2);

    }
}
```

运行结果：

main 访问到了
main 访问到了
cn.ideal.single.Lazy1@4554617c
cn.ideal.single.Lazy1@74a14482

实例化 lazy1 后，其执行了修改 ideal 这个布尔值为 false，从而绕过了判断，再次破坏了单例

所以，可以得出，这几种方式都是不安全的，都有着被反射破坏的风险

## (二) 枚举类不会被破坏

上面在讲解枚举单例方式的时候就提过《Effective Java》中提到，**即使是在面对复杂的序列化或者反射攻击的时候，（枚举单例方式）绝对防止多次实例化**，下面来看一下是不是这样：

首先说一个前提条件：这是 Constructor 下的 newInstance 方法节选，也就是说遇到枚举时，会报异常，也就是不允许通过反射创建枚举

```java
if ((clazz.getModifiers() & Modifier.ENUM) != 0)
    throw new IllegalArgumentException("Cannot reflectively create enum objects");
```

看一下我们枚举单例类 EnumSingle 生成的字节码文件，可以看到其中有一个无参构造，也就是说，我们还是只需要拿到 getDeclaredConstructor(null) 就行了

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1ea9334a57f40e3a3198226d0213478~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1ea9334a57f40e3a3198226d0213478~tplv-k3u1fbpfcp-zoom-1.image)

代码如下：

```java
public enum EnumSingle {
    IDEAL;

    public static void main(String[] args) throws Exception {
        EnumSingle ideal1 = EnumSingle.IDEAL;
        // 获得其空参构造器
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);
        // 使得可操作性该 declaredConstructor 对象
        declaredConstructor.setAccessible(true);
        // 反射实例化
        EnumSingle ideal2 = declaredConstructor.newInstance();
        System.out.println(ideal1);
        System.out.println(ideal2);
    }
}
```

运行结果却是出人意料：

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1bc11bcaa2d451aa6245c4e84cfa5b3~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1bc11bcaa2d451aa6245c4e84cfa5b3~tplv-k3u1fbpfcp-zoom-1.image)

提示竟然是找不到这个空参？？？字节码中可是却是存在的啊

```java
Exception in thread "main" java.lang.NoSuchMethodException: cn.ideal.single.EnumSingle.<init>()
```

自己 javap 反编译一下，可以看到还是有这个空参

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0602e1dd72054e20b4e3f0b405afb2b4~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0602e1dd72054e20b4e3f0b405afb2b4~tplv-k3u1fbpfcp-zoom-1.image)

换成 jad 再看看（将 jad.exe 放在字节码文件同目录下）

- 执行：`jad -sjava EnumSingle.class`

提示已经反编译结束：Parsing EnumSingle.class... Generating EnumSingle.java

打开生成的 java 文件，终于发现，原来它是一个带参构造，同时有两个参数，String 和 int

[![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd397da604b04c3aa5099979515ed727~tplv-k3u1fbpfcp-zoom-1.image)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd397da604b04c3aa5099979515ed727~tplv-k3u1fbpfcp-zoom-1.image)

所以下面，我们只需要修改原来的无参为有参即可：

```java
public enum EnumSingle {
    IDEAL;

    public static void main(String[] args) throws Exception {
        EnumSingle ideal1 = EnumSingle.IDEAL;
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);
        // 使得可操作性该 declaredConstructor 对象
        declaredConstructor.setAccessible(true);
        // 反射实例化
        EnumSingle ideal2 = declaredConstructor.newInstance();
        System.out.println(ideal1);
        System.out.println(ideal2);
    }
}
```

这样就没问题了，提示了我们想要的错误：Cannot reflectively create enum objects

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4192c08110441aa8bedeafdf2f2bd2e~tplv-k3u1fbpfcp-zoom-1.image)

这也说明，枚举类的单例模式写法确实不会被反射破坏！

# 7.Spring中事务使用范例，事务传播机制实现逻辑，底层原理，事务回滚，事务嵌套

https://blog.csdn.net/LeoHan163/article/details/106948631/

# 8.Redis中zset底层实现原理

https://blog.csdn.net/weichi7549/article/details/107335133

## 9.mysql幻读问题next_lock是基于索引实现的，那如果没有索引怎么处理的幻读的

https://blog.csdn.net/justlpf/article/details/106833800
四种隔离级别

https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247489236&idx=1&sn=5067c4dffc609d0be9fb01405199cfea&chksm=eb5393e2dc241af47d98ad9a947996c1824daa789fd384b8c0dd8a2fea5cd4faa756c4e8b918&scene=21#wechat_redirect

## 10.Mysql 聚簇索引和非聚簇索引

https://blog.csdn.net/weixin_36015463/article/details/114337060

**使用索引的注意事项**

使用索引时，有以下一些技巧和注意事项：

1.索引不会包含有NULL值的列

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

2.使用短索引

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

3.索引列排序

MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

4.like语句操作

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

5.不要在列上进行运算

复制代码 代码如下:


select * from users where YEAR(adddate)<2007;

将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成:

复制代码 代码如下:

select * from users where adddate<‘2007-01-01';

6.不使用NOT IN和<>操作

## 11.zk watch机制原理实现

https://blog.csdn.net/LiuRenyou/article/details/109390386

## 12.niginx tomcat工作模型，是否用到了IO多路复用

https://blog.csdn.net/Peelarmy/article/details/109316382

## 13.手写单链表反转

https://blog.csdn.net/weixin_39898248/article/details/114224031

## 14.垃圾回收器如何处理循环引用

http://www.jcodecraeer.com/a/chengxusheji/java/2015/0612/3034.html

## 15.volatile可见性，防重排，举个例子说一下

https://blog.csdn.net/qq_41566772/article/details/99688430

## 16.如何保证kafka消息不丢失

https://blog.csdn.net/tian583391571/article/details/105780965

## 17.线程相关

#### 1) 什么是线程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支 持，它也是一个很好的卖点。

#### 2) 线程和进程有什么区别？

线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

#### 3) 如何在Java中实现线程？

在语言层面有三种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承 java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。第三种 实现Callable<>接口并重写call方法。

#### 4) 用Runnable还是Thread？

这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使 用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好 了。

#### 6) Thread 类中的start() 和 run() 方法有什么区别？

这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。

#### 7) Java中Runnable和Callable有什么不同？

Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在 JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。

#### 8) Java中的volatile 变量是什么？

volatile是一个特殊的修饰符，只有成员变量才能使用它。保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

#### 11) 什么是线程安全？Vector是一个线程安全类吗？

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

#### 12) Java中notify 和 notifyAll有什么区别？

这又是一个***钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等 待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

#### 17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？

这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

#### 18) 什么是ThreadLocal变量？

ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。

ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比synchronized要简单得多。

ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。




#### 19) 什么是FutureTask？

在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完 成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包 装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

#### 20) Java中interrupted 和 isInterruptedd方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用[静态方法](http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html)Thread.interrupted()来 检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛 出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。

#### 21) 为什么wait和notify方法要在同步块中调用？

主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。

#### 22) 为什么你应该在循环中检查等待条件?

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来 时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方 法效果更好的原因，你可以在[Eclipse](http://res.importnew.com/eclipse)中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《[Effective Java](http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B000WJOUPA&linkCode=as2&tag=job0ae-20)》这本书中的线程和同步章节。

#### 23) Java中的同步集合与并发集合有什么区别？

同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在 多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分 区等现代技术提高了可扩展性。

#### 24） Java中堆和栈有什么不同？

为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈 调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。

#### 25） 什么是线程池？ 为什么要使用它？

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时 候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短 的任务的程序的可扩展线程池）。

#### 26） 如何写代码来解决生产者消费者问题？

在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比 较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，[这篇教程](http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html)有实现它。

#### 27） 如何避免死锁？

Java多线程中的死锁
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

#### 28) Java中活锁和死锁有什么区别？

这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行。

#### 29） 怎么检测一个线程是否拥有锁？

我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。

#### 30) 你如何在Java中获取线程堆栈？

对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在 Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。

#### 31) JVM中哪个参数是用来控制线程的栈堆栈小的

这个问题很简单， -Xss参数用来控制线程的堆栈大小。

#### 32） Java中synchronized 和 ReentrantLock 有什么不同？

Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁 时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。

#### 33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。

#### 34) Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

#### 35） Java中ConcurrentHashMap的并发度是什么？

ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。

#### 36） Java中Semaphore是什么？

Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前 会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采 取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。

#### 37）如果你提交任务时，线程池队列已满。会时发会生什么？

这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

#### 38) Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线 程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

#### 39) 什么是阻塞式方法？

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是 指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

#### 40) Swing是线程安全的吗？ 为什么？

你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常 常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更 新。

#### 41） Java中invokeAndWait 和 invokeLater有什么区别？

这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进 度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而 invokeLater()方法是异步调用更新组件的。

#### 42) Swing API中那些方法是线程安全的？

这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。

#### 43) 如何在Java中创建Immutable对象？

这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java 没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员 声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章[how to make an object Immutable in Java](http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html)有详细的教程，看完你可以充满自信。

#### 44） Java中的ReadWriteLock是什么？

一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程 持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读 锁。

#### 45) 多线程中的忙循环是什么?

忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可 能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。

#### 46）volatile 变量和 atomic 变量有什么不同？

这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性 的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

#### 47) 如果同步块内的线程抛出异常会发生什么？

这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在[finally block](http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html)里释放锁实现。

#### 48） 单例模式的双检锁是什么？

这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和 Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复 杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。

#### 49） 如何在Java中创建线程安全的Singleton？

这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。

#### 50) 写出3条你遵循的多线程最佳实践

这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：

- 给你的线程起个有意义的名字。
  这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
- 避免锁定和缩小同步的范围
  锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
- 多用同步类少用wait 和 notify
  首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断 优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
- 多用并发集合少用同步集合
  这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。

#### 51) 如何强制启动一个线程？

这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。

#### 52) Java中的fork join框架是什么？

fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块 设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。

#### 53） Java多线程中调用wait() 和 sleep()方法有什么不同？

Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

## 18.Socket知识点

1. 网络架构模型
1.1 OSI参考模型

OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。

1.2 TCP/IP五层模型


1.3 各层简述


应用层
应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。

传输层
建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

网络层
本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

1.4 TCP、UPD简述
TCP
TCP是（Tranfer Control Protocol）的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。
UDP
UDP是（User Datagram Protocol）的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。
2. Socket编程
2.1 什么是socket?
在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。
Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

2.2 Socket原理
Socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样。
套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。
客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
2.3 通信流程


相关面试题
面试题一
编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度

下面是TCP实现
package com.soket;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TcpDemo {
    public static void main(String[] args) {
        try {
            // 创建一个ServerSocket,监听Client端发来的数据
            ServerSocket serverSocket = new ServerSocket(65000);
            Socket socket = serverSocket.accept();
            new TcpServerThread(socket).run();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class TcpServerThread extends Thread {
    private Socket socket;

    public TcpServerThread(Socket socket) {
        this.socket = socket;
    }
    
    @Override
    public void run() {
        try {
            // TCP是有连接的，取出socket对应的输入、输出流
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();
    
            // 读取输入流（client发来的消息）
            int len = 0;
            byte[] bufferArr = new byte[1024];
            len = inputStream.read(bufferArr);
            String content = new String(bufferArr, 0, len);
    
            // 业务xxx，此处为打印发来的字符串，并计算字符串长度
            System.out.println(content);
    
            // 将数据封装成byte[]，通过输出流传回客户端
            String sendData = new String(String.valueOf(content.length()));
            outputStream.write(sendData.getBytes(),0,sendData.length());
            outputStream.flush();
    
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class TcpClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("127.0.0.1", 65000);
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();

            byte[] sendData = "服务端你好！".getBytes();
            outputStream.write(sendData,0,sendData.length);
            outputStream.flush();
    
            int len = 0;
            byte[] bufferArr = new byte[1024];
            len = inputStream.read(bufferArr);
            String content = new String(bufferArr, 0, len);
            System.out.println(content);
    
        }catch (Exception e){
            e.printStackTrace();
        }
    
    }
}
UDP实现
package com.soket;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UdpDemo {
    public static void main(String[] args) {
        // 别问我为啥这嘎达啥也不写，问就是就空着玩儿～
    }
}


//服务端代码
class UDPServer {

    public static void main(String[] args) throws Exception {
        // 服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket pocket = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(pocket);
    
        byte[] data = pocket.getData(); //从DatagramPacket对象中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, pocket.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        // 服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, pocket.getAddress(), pocket.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
}

//客户端的代码
class UDPClient {

    public static void main(String[] args) throws Exception {
        // 客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        // 要发送给服务端的数据
        byte[] buf = "Hello World".getBytes();
        // 将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName("127.0.0.1");
        // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        // 发送数据给服务端
        socket.send(packet);
    
        // 客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        // 创建DtagramPacket对象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        // 将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        // 将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    
    }
}
面试题二：TCP和UDP的区别
UDP：

每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。
UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。
UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方
TCP：

面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。
TCP传输数据没有大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。
TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。
应用：

TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。
UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。
